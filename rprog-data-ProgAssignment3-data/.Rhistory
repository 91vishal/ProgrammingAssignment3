find.package("devtools")
install.packages("devtools")
library(devtools)
library(devtools)
find_rtools()
jpeg("graph1.jpg")
x<-1:10
y<-c(1,5,14,21,39,50,63,85,102,139)
plot(x,y,type="l")
plot(x,y,type="l")
plot(x,y,type="o")
jpeg("question2b_function.jpg")
x<-1:10
y<-c(1,7,7,37,48,48,198,198,253,314)
plot(x,y,type="l")
jpeg("question2a_depth.jpg")
x<-1:10
y<-c(0,1,2,2,3,3,3,3,3,4)
plot(x,y,type='o')
jpeg("question2b_depth.jpg")
x<-1:10
y<-c(0,2,2,4,4,4,6,6,6,8)
jpeg("question2b_depth.jpg")
x<-1:10
y<-c(0,2,2,4,4,4,6,6,6,8)
plot(x,y,type='o')
print(x)
x<-5
x
x<-1:20
print(X)
x<-1:20
x
wd
getwd()
colmean <- function(y){}
colmean <- function(y){}
colmean <- function(y){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[, i])
}
means
}
colmean(airquality)
colmean <- function(y){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[,i])
}
means
}
colmean(airquality)
colmean <- function(y){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[i,])
}
means
}
colmean(airquality)
colmean <- function(y, removeNA= TRUE){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[,i], na.rm=removeNA)
}
means
}
colmean(airquality)
f <- function(x){
g <- function(y){
y+z
}
z<-4
x+g(x)
}
z<-10
f <- function(x){
g <- function(y){
y+z
}
z<-4
x+g(x)
}
z<-10
f(3)
x<-5
y<-if(x<3){
NA
}
else
{
10
}
x<-5
y<-if(x<3){
NA
}
else{
10
}
x<-5
y<-if(x<3){
NA
} else {
10
}
y
x<-1:10
if(x>5){
x<-0
}
cube<-function(x,n){
x^3
}
cube(3)
?iris
library(datasets)
data(iris)
data(iris)
iris
split(iris,colmeans(x[,virginica]))
split(iris,colMeans(x[,virginica]))
s <- split (iris, iris$virginica)
s <- split (iris, iris$virginica)
s <- split (iris, f = iris$virginica)
s <- split (iris, f = iris$virginica)
iris$virginica
iris
iris$species
iris$Species
$'3'
iris$Species
s <- split (iris, f = iris$Species)
lapply(s, function(x) colMeans(x[, Sepal.Length]))
lapply(s, function(x) colMeans(x[, c(Sepal.Length)]))
lapply(s, function(x) colMeans(x[, c(Sepal.Length)]))
lapply(s, function(x) colMeans(x[, Sepal.Length]))
iris$Sepal.Length
lapply(s, function(x) colMeans(x[, iris$Sepal.Length]))
lapply(s, function(x) colMeans(x[, "Sepal.Length"]))
lapply(s, function(x) colMeans(x[, c("Sepal.Length")]))
sapply(s, function(x) colMeans(x[, c("Sepal.Length")]))
lapply(s, function(x) colMeans(x[, "Sepal.Length"]))
apply(s, 1,mean)
apply(iris, 1,mean)
lapply(s, function(x) colMeans(x[, "Sepal.Length"]))
x <- c(rnorm(10),runif(10),rnorm(10,1))
lapply(s, function(x) colMeans(x[, "Sepal.Length"]))
apply(iris[1:4],MARGIN=2,mean)
apply(iris[1:4],MARGIN=5,mean)
iris
apply(iris, 2, mean)
apply(iris[1:4], 2, mean)
apply(iris[1:4], 1, mean)
colmeans(iris)
mtcars
tapply(mtcars$mpg,mtcars$cyl,mean)
tapply(mtcars$cyl,mtcars$mpg,mean)
lapply(mtcars,mean)
tapply(mtcars$hp,mtcars$cyl,mean)
209.21429 - 82.63636
debug(ls)
l
ls
iris
tapply(iris$Sepal.Length,iris$virginica,mean)
tapply(iris$Sepal.Length,iris$species,mean)
tapply(iris$Sepal.Length,iris$Species,mean)
tapply(iris$Species,iris$Sepal.Length,mean)
tapply(iris$Sepal.Length,iris$Species,mean)
apply(iris[,1:4],2,mean)
debug(ls)
ls
x <- matrix(1:6,2,3)
x
solve(x)
x<-matrix(1:6,2,2)
x
solve(x)
makeCacheMatrix <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<-matrix(1:4,2,2)
m <<- NULL
}
makeCacheMatrix <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<-matrix(1:4,2,2)
m <<- NULL
}
get <- function() x
x$get()
data<x$get()
data
makeCacheMatrix <- function(x = matrix()) {
result <- NULL
set <- function(y) {
x <<-y
result <<- NULL
}
get <- function() x
setinverse <- function(inverse) result <<- inverse
getinverse <- function() result
list(set = set, get = get,
setinverse = setinverse,
getimverse = getinverse)
}
x = rbind(c(2,1),c(3,7))
m = makeCacheMatrix(x)
m$get()
makeCacheMatrix <- function(x = matrix()) {
result <- NULL
set <- function(y) {
x <<-y
result <<- NULL
}
get <- function() x
setinverse <- function(inverse) result <<- inverse
getinverse <- function() result
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
makeCacheMatrix(x)
x$get()
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<-y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
x
# Matrix inversion is usually a costly computation
# and there may be some benefit to caching the inverse
# of a matrix rather than compute it repeatedly.
# The following two functions are used to cache the inverse of a matrix.
# makeCacheMatrix creates a list containing a function to
# 1. set the value of the matrix
# 2. get the value of the matrix
# 3. set the value of inverse of the matrix
# 4. get the value of inverse of the matrix
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<-y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
# The following function returns the inverse of the matrix. It first checks if
# the inverse has already been computed. If so, it gets the result and skips the
# computation. If not, it computes the inverse, sets the value in the cache via
# setinverse function.
# This function assumes that the matrix is always invertible.
cachemean <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data from memory")
return(inv)
}
data <- x$get()
inv <- mean(data, ...)
x$setinverse(inv)
inv
}
x
x<-rbind(c(2,1),c(4,2))
x
m=makeCacheMatrix(x)
m$get()
# Matrix inversion is usually a costly computation
# and there may be some benefit to caching the inverse
# of a matrix rather than compute it repeatedly.
# The following two functions are used to cache the inverse of a matrix.
# makeCacheMatrix creates a list containing a function to
# 1. set the value of the matrix
# 2. get the value of the matrix
# 3. set the value of inverse of the matrix
# 4. get the value of inverse of the matrix
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<-y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
# The following function returns the inverse of the matrix. It first checks if
# the inverse has already been computed. If so, it gets the result and skips the
# computation. If not, it computes the inverse, sets the value in the cache via
# setinverse function.
# This function assumes that the matrix is always invertible.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data from memory")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
x
x<-rbind(c(1,3),c(4,2))
m=makeCacheMatrix(x)
m$get(x)
m$get()
source('D:/NEU DOCS/Coursera/Assign2.R')
x<-rbind(c(2,3),c(5,7))
m=makeCacheMatrix(x)
m$get()
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<-y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
#if the inverse of matrix is in cache
if(!is.null(inv)) {
# get the inverse of matrix from cache
message("getting cached data from memory")
return(inv)
}
#Calculate the inverse of matrix as it is not in cache.
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
x<- rbind(c(2,3),c(4,6))
x
m=makeCacheMatrix(x)
m
m$get()
cacheSolve(x)
cacheSolve(m)
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
#if the inverse of matrix is in cache
if(!is.null(inv)) {
# get the inverse of matrix from cache
message("getting cached data from memory")
return(inv)
}
#Calculate the inverse of matrix as it is not in cache.
data <- x$get()
inv <- solve(data,...)
x$setinverse(inv)
inv
}
x
cacheSolve(m)
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<-y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
#if the inverse of matrix is in cache
if(!is.null(inv)) {
# get the inverse of matrix from cache
message("getting cached data from memory")
return(inv)
}
#Calculate the inverse of matrix as it is not in cache.
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
x<- rbind(c(1,-1/4),c(-1/4,1))
x
m=makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
set.seed(1)
rpois(5,2)
rpois(5,2)
rpois(5,2)
set.seed(1)
rpois(5,2)
best <- function(state, outcome) {
## Read outcome data
## Check that state and outcome are valid
## Return hospital name in that state with lowest 30-day death
## rate
options(warn=-1)
## Read outcome data
data <- read.csv("outcome-of-care-measures.csv",colClasses="character")
## Check that state and outcome are valid
states <- data[, 7]
outcomes <- c("heart attack","heart failure","pneumonia")
if((state %in% states) == FALSE){
stop(print("invalid state"))
}
else if((outcome %in% outcomes) == FALSE){
stop(print("invalid outcome"))
}
if(outcome == "heart attack"){
outcome_col <- 11
}
else if(outcome == "heart failure"){
outcome_col <- 17
}
else {
outcome_col <- 23
}
#get the new data for that state after removing NA values
data_state <- data[data$State == state,]
data_filtered <- as.numeric(data[, outcome_col])
bad <- is.na(data_filtered)
desired_data <- data_state[!bad, ]
new_data <-as.numeric(desired_data[, outcome_col])
new_data<- new_data[complete.cases(new_data)]  #remove NA values
## Return hospital name in that state with lowest 30-day death
## rate
desired_rows <- which(new_data == min(new_data))
desired_hospitals <- desired_data[desired_rows,2]
#if there are multiple hospitals with the minimum outcome value, then
#return the first hospital name from the alphabetically sorted hospital
#names list
if(length(desired_hospitals) > 1){
sorted_hospitals <- sort(desired_hospitals)
sorted_hospitals[1]
}
else{
desired_hospitals #return the desired hospital name
}
}
best("TX", "heart attack")
source("best.R")
getwd()
setwd(D:/NEU DOCS/Coursera/rprog-data-ProgAssignment3-data)
setwd("D:/NEU DOCS/Coursera/rprog-data-ProgAssignment3-data")
getwd()
source(best.R)
source("best.R")
getwd()
